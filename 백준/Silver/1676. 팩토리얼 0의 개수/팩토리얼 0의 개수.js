const fs = require('fs');
const n = Number(fs.readFileSync('/dev/stdin').toString().trim());
/**
 * 방법 : 팩토리얼을 구한 후 마지막 인덱스 부터 탐색하여 0의 개수 구하기
 * =>단순하게 일반적인 재귀로 구현하면 매우 큰 연산이됨(1<=n<=500)
 *
 * 0!은 1, 1!은 1, 2!은 2이다.
 * 주어진 수에서 0이 없으면 0개임
 * 애초에 5!부터 일의자리가 무조건 0이기에 5!이상은 0의 개수를 반드시 구할 수 있음
 *
 *
 * 500!은 말도 안되게 큰 숫자이므로, BigInt로 처리할 수 있을 것 같긴하지만, 신뢰가 떨어지므로
 * 규칙을 찾아야 한다.
 *
 * 끝에서 부터 0을 찾기 때문에 결국 소인수 분해를 했을 때 10의 개수를 찾는것과 동일하다.
 *
 * 10을 만들려면 2와 5과 필요하기 때문에 둘의 개수를 찾아야하는데,
 * 팩토리얼 특성상 전에 곱연산이 영향을 주기 때문에 최초의 0이 나오는 5!부터
 * 2의 개수가 5보다 월등히 많아질 수 밖에 없다.(2,4,6,8,10...)(5,10,15,20,25...)
 *
 * 때문의 결국 5의 개수를 찾는 것이 문제의 키포인트이다.
 *
 * 팩토리얼을 직접 소인수 분해할 필요는 당연히 없고,
 *
 *
 *
 * 0~4 ! : 0
 * 5~9 ! : 1
 * 10~14 ! : 2
 * 15~19! : 3
 * 20~24! : 4
 * 25~29! : 6 //25가 5의 개수가 2개임
 * 30~34! : 7
 * 35~39! : 8
 * 40~44! : 9
 * 45~49! : 10
 * 50~54! : 12 //50이 5의 개수가 2개임
 *
 * 5의 배수인 숫자가 걸리면 그때 cnt를 증가시키되, 5의 개수만큼 반복해서 증가
 *
 */

let cnt = 0;

for (let i = 1; i <= n; i++) {
  let powNum = i;

  while (powNum % 5 === 0) {
    //5의 배수이면
    cnt++;
    powNum = Math.floor(powNum / 5); //5의 개수 카운팅을 위한 연산
  }
}

console.log(cnt);
